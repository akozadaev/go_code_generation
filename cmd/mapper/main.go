package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

var (
	typeName = flag.String("type", "", "Имя типа структуры модели")
	dtoName  = flag.String("dto", "", "Имя типа структуры DTO")
	output   = flag.String("output", "", "Имя выходного файла")
)

const mapperTemplate = `// Code generated by mapper generator. DO NOT EDIT.
// This file was auto-generated from {{.SourceFile}}

package {{.PackageName}}

import (
	{{- if .NeedTime}}
	"time"
	{{- end}}
	{{- range .Imports}}
	"{{.}}"
	{{- end}}
)

// {{.ToDTOFuncName}} преобразует модель {{.ModelType}} в DTO {{.DTOType}}
func (m *{{.ModelType}}) {{.ToDTOFuncName}}() *{{.DTOType}} {
	if m == nil {
		return nil
	}
	dto := &{{.DTOType}}{
		{{- range .Fields}}
		{{.DTOFieldName}}: {{.ConvertToDTO}},
		{{- end}}
	}
	return dto
}

// {{.FromDTOFuncName}} создает модель {{.ModelType}} из DTO {{.DTOType}}
func {{.FromDTOFuncName}}(dto *{{.DTOType}}) *{{.ModelType}} {
	if dto == nil {
		return nil
	}
	model := &{{.ModelType}}{
		{{- range .Fields}}
		{{.ModelFieldName}}: {{.ConvertFromDTO}},
		{{- end}}
	}
	return model
}

// {{.SliceToDTOFuncName}} преобразует слайс моделей {{.ModelType}} в слайс DTO {{.DTOType}}
func {{.SliceToDTOFuncName}}(models []{{.ModelType}}) []{{.DTOType}} {
	if models == nil {
		return nil
	}
	dtos := make([]{{.DTOType}}, len(models))
	for i := range models {
		dtos[i] = *models[i].{{.ToDTOFuncName}}()
	}
	return dtos
}

// {{.SliceFromDTOFuncName}} создает слайс моделей {{.ModelType}} из слайса DTO {{.DTOType}}
func {{.SliceFromDTOFuncName}}(dtos []{{.DTOType}}) []{{.ModelType}} {
	if dtos == nil {
		return nil
	}
	models := make([]{{.ModelType}}, len(dtos))
	for i := range dtos {
		models[i] = *{{.FromDTOFuncName}}(&dtos[i])
	}
	return models
}
`

type FieldInfo struct {
	ModelFieldName string
	DTOFieldName   string
	ModelType      string
	DTOType        string
	ConvertToDTO   string
	ConvertFromDTO string
}

type TemplateData struct {
	PackageName          string
	SourceFile           string
	ModelType            string
	DTOType              string
	ToDTOFuncName        string
	FromDTOFuncName      string
	SliceToDTOFuncName   string
	SliceFromDTOFuncName string
	Fields               []FieldInfo
	Imports              []string
	NeedTime             bool
}

func main() {
	flag.Parse()

	if *typeName == "" || *dtoName == "" || *output == "" {
		fmt.Fprintf(os.Stderr, "Использование: %s -type=ModelType -dto=DTOType -output=output.go [files...]\n", os.Args[0])
		flag.PrintDefaults()
		os.Exit(1)
	}

	args := flag.Args()
	if len(args) == 0 {
		fmt.Fprintf(os.Stderr, "Ошибка: не указаны файлы для обработки\n")
		os.Exit(1)
	}

	fset := token.NewFileSet()
	var modelStruct, dtoStruct *ast.StructType
	var packageName string
	var imports []string

	// Парсим файлы для поиска структур
	for _, filename := range args {
		file, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Ошибка парсинга файла %s: %v\n", filename, err)
			continue
		}

		packageName = file.Name.Name

		// Собираем импорты
		for _, imp := range file.Imports {
			impPath := strings.Trim(imp.Path.Value, `"`)
			imports = append(imports, impPath)
		}

		// Ищем структуры
		ast.Inspect(file, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.GenDecl:
				if x.Tok == token.TYPE {
					for _, spec := range x.Specs {
						ts, ok := spec.(*ast.TypeSpec)
						if !ok {
							continue
						}

						if ts.Name.Name == *typeName {
							if st, ok := ts.Type.(*ast.StructType); ok {
								modelStruct = st
							}
						}

						if ts.Name.Name == *dtoName {
							if st, ok := ts.Type.(*ast.StructType); ok {
								dtoStruct = st
							}
						}
					}
				}
			}
			return true
		})
	}

	if modelStruct == nil {
		fmt.Fprintf(os.Stderr, "Ошибка: структура %s не найдена\n", *typeName)
		os.Exit(1)
	}

	if dtoStruct == nil {
		fmt.Fprintf(os.Stderr, "Ошибка: структура %s не найдена\n", *dtoName)
		os.Exit(1)
	}

	// Создаем маппинг полей
	modelFields := extractFields(modelStruct, fset)
	dtoFields := extractFields(dtoStruct, fset)

	fields, needTime := matchFields(modelFields, dtoFields)

	// Фильтруем импорты (убираем time, если он не нужен или будет добавлен через шаблон)
	filteredImports := uniqueStrings(imports)
	if needTime {
		// Удаляем time из импортов, так как он будет добавлен через шаблон
		var importsWithoutTime []string
		for _, imp := range filteredImports {
			if imp != "time" {
				importsWithoutTime = append(importsWithoutTime, imp)
			}
		}
		filteredImports = importsWithoutTime
	} else {
		// Если time не нужен, тоже убираем его из импортов
		var importsWithoutTime []string
		for _, imp := range filteredImports {
			if imp != "time" {
				importsWithoutTime = append(importsWithoutTime, imp)
			}
		}
		filteredImports = importsWithoutTime
	}

	// Генерируем код
	data := TemplateData{
		PackageName:          packageName,
		SourceFile:           args[0],
		ModelType:            *typeName,
		DTOType:              *dtoName,
		ToDTOFuncName:        "To" + *dtoName,
		FromDTOFuncName:      *dtoName + "To" + *typeName,
		SliceToDTOFuncName:   "SliceTo" + *dtoName,
		SliceFromDTOFuncName: *dtoName + "SliceTo" + *typeName,
		Fields:               fields,
		Imports:              filteredImports,
		NeedTime:             needTime,
	}

	tmpl, err := template.New("mapper").Parse(mapperTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Ошибка парсинга шаблона: %v\n", err)
		os.Exit(1)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "Ошибка выполнения шаблона: %v\n", err)
		os.Exit(1)
	}

	// Форматируем код
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Ошибка форматирования кода: %v\n", err)
		os.Stderr.Write(buf.Bytes())
		os.Exit(1)
	}

	// Записываем в файл
	if err := os.WriteFile(*output, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Ошибка записи файла: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Сгенерирован файл: %s\n", *output)
}

type Field struct {
	Name string
	Type string
	Tag  string
}

func extractFields(structType *ast.StructType, fset *token.FileSet) []Field {
	_ = fset // Используется для будущих расширений
	var fields []Field
	for _, f := range structType.Fields.List {
		for _, name := range f.Names {
			field := Field{
				Name: name.Name,
				Type: typeToString(f.Type),
			}
			if f.Tag != nil {
				field.Tag = strings.Trim(f.Tag.Value, "`")
			}
			fields = append(fields, field)
		}
	}
	return fields
}

func typeToString(expr ast.Expr) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.SelectorExpr:
		// Обработка time.Time
		if ident, ok := x.X.(*ast.Ident); ok && ident.Name == "time" && x.Sel.Name == "Time" {
			return "time.Time"
		}
		return typeToString(x.X) + "." + x.Sel.Name
	case *ast.ArrayType:
		if x.Len == nil {
			return "[]" + typeToString(x.Elt)
		}
		return fmt.Sprintf("[%s]%s", typeToString(x.Len), typeToString(x.Elt))
	case *ast.StarExpr:
		return "*" + typeToString(x.X)
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", typeToString(x.Key), typeToString(x.Value))
	default:
		return "unknown"
	}
}

func extractTagValue(tag, key string) string {
	if tag == "" {
		return ""
	}
	for tag != "" {
		i := 0
		for i < len(tag) && tag[i] != ' ' && tag[i] != '\t' {
			i++
		}
		pair := tag[:i]
		tag = tag[i:]
		if len(tag) > 0 {
			tag = tag[1:]
		}
		if pair == "" {
			continue
		}
		i = 0
		for i < len(pair) && pair[i] != ':' {
			i++
		}
		if i == 0 || i >= len(pair) {
			continue
		}
		tagKey := pair[:i]
		tagValue := pair[i+1:]
		if tagKey == key {
			tagValue = strings.Trim(tagValue, `"`)
			if idx := strings.Index(tagValue, ","); idx != -1 {
				tagValue = tagValue[:idx]
			}
			return tagValue
		}
	}
	return ""
}

func matchFields(modelFields, dtoFields []Field) ([]FieldInfo, bool) {
	// Создаем маппинг по тегам mapper
	modelMap := make(map[string]Field)
	for _, f := range modelFields {
		mapperTag := extractTagValue(f.Tag, "mapper")
		if mapperTag != "" {
			modelMap[mapperTag] = f
		}
	}

	dtoMap := make(map[string]Field)
	for _, f := range dtoFields {
		jsonTag := extractTagValue(f.Tag, "json")
		if jsonTag != "" {
			if idx := strings.Index(jsonTag, ","); idx != -1 {
				jsonTag = jsonTag[:idx]
			}
			dtoMap[jsonTag] = f
		}
	}

	var result []FieldInfo
	needTime := false

	// Сопоставляем поля по тегам
	for mapperTag, modelField := range modelMap {
		dtoField, ok := dtoMap[mapperTag]
		if !ok {
			continue
		}

		convertToDTO := fmt.Sprintf("m.%s", modelField.Name)
		convertFromDTO := fmt.Sprintf("dto.%s", dtoField.Name)

		// Специальная обработка для time.Time -> string
		if modelField.Type == "time.Time" && dtoField.Type == "string" {
			convertToDTO = fmt.Sprintf("m.%s.Format(time.RFC3339)", modelField.Name)
			convertFromDTO = fmt.Sprintf("parseTime(dto.%s)", dtoField.Name)
			needTime = true
		}

		// Обработка слайсов структур (например, []OrderItem -> []OrderItemDTO)
		if strings.HasPrefix(modelField.Type, "[]") && strings.HasPrefix(dtoField.Type, "[]") {
			modelSliceType := strings.TrimPrefix(modelField.Type, "[]")
			dtoSliceType := strings.TrimPrefix(dtoField.Type, "[]")
			// Если это разные типы, используем функцию преобразования слайса
			if modelSliceType != dtoSliceType {
				// Ищем функцию вида SliceToXXXDTO или OrderItemSliceToOrderItemDTO
				sliceMapperFunc := fmt.Sprintf("SliceTo%s", dtoSliceType)
				reverseSliceMapperFunc := fmt.Sprintf("%sSliceTo%s", dtoSliceType, modelSliceType)
				convertToDTO = fmt.Sprintf("%s(m.%s)", sliceMapperFunc, modelField.Name)
				convertFromDTO = fmt.Sprintf("%s(dto.%s)", reverseSliceMapperFunc, dtoField.Name)
			}
		}

		// Обработка для указателей
		if strings.HasPrefix(modelField.Type, "*") && !strings.HasPrefix(dtoField.Type, "*") {
			baseType := strings.TrimPrefix(modelField.Type, "*")
			if baseType == "string" {
				convertToDTO = fmt.Sprintf("derefString(m.%s)", modelField.Name)
			} else {
				convertToDTO = fmt.Sprintf("*m.%s", modelField.Name)
			}
		}
		if !strings.HasPrefix(modelField.Type, "*") && strings.HasPrefix(dtoField.Type, "*") {
			convertFromDTO = fmt.Sprintf("&dto.%s", dtoField.Name)
		}

		result = append(result, FieldInfo{
			ModelFieldName: modelField.Name,
			DTOFieldName:   dtoField.Name,
			ModelType:      modelField.Type,
			DTOType:        dtoField.Type,
			ConvertToDTO:   convertToDTO,
			ConvertFromDTO: convertFromDTO,
		})
	}

	return result, needTime
}

func uniqueStrings(slice []string) []string {
	seen := make(map[string]bool)
	var result []string
	for _, s := range slice {
		if !seen[s] {
			seen[s] = true
			result = append(result, s)
		}
	}
	return result
}
